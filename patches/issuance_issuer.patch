diff --git a/issuance/issuer.go b/issuance/issuer.go
index e89143ea0..f0015706e 100644
--- a/issuance/issuer.go
+++ b/issuance/issuer.go
@@ -128,8 +128,8 @@ func LoadChain(certFiles []string) ([]*Certificate, error) {
 	lastCert := certs[len(certs)-1]
 	err = lastCert.CheckSignatureFrom(lastCert.Certificate)
 	if err != nil {
-		return nil, fmt.Errorf(
-			"final cert in chain (%q; %q) must be self-signed (used only for validation): %w",
+		fmt.Printf(
+			"WARNING: final cert in chain (%q; %q) should be self-signed (used only for validation): %w\n",
 			lastCert.Subject, certFiles[len(certFiles)-1], err)
 	}
 
@@ -149,7 +149,7 @@ type IssuerConfig struct {
 	Active bool
 
 	IssuerURL  string `validate:"required,url"`
-	CRLURLBase string `validate:"required,url,startswith=http://,endswith=/"`
+	CRLURLBase string `validate:"required,url,startswith=http://"`
 
 	// TODO(#8177): Remove this.
 	OCSPURL string `validate:"omitempty,url"`
@@ -236,9 +236,6 @@ func newIssuer(config IssuerConfig, cert *Certificate, signer crypto.Signer, clk
 	if !strings.HasPrefix(config.CRLURLBase, "http://") {
 		return nil, fmt.Errorf("crlURLBase must use HTTP scheme, got %q", config.CRLURLBase)
 	}
-	if !strings.HasSuffix(config.CRLURLBase, "/") {
-		return nil, fmt.Errorf("crlURLBase must end with exactly one forward slash, got %q", config.CRLURLBase)
-	}
 
 	// We require that all of our issuers be capable of both issuing certs and
 	// providing revocation information.
